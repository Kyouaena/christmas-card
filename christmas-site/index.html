<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas - ç²’å­ç‰¹æ•ˆ</title>
    <style>
        /* --- 1. æ²‰æµ¸å¼ UI è®¾è®¡ (å¤åˆ»æˆªå›¾é£æ ¼) --- */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* ç•Œé¢è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        .header {
            text-align: center; margin-top: 5vh;
            color: #d4af37; /* é¦™æ§Ÿé‡‘ */
            font-size: clamp(24px, 5vw, 48px); /* å“åº”å¼å­—ä½“ */
            font-weight: 300; letter-spacing: 5px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            font-family: "Times New Roman", serif;
        }

        /* å·¦ä¸‹è§’æ§åˆ¶åŒº */
        .controls {
            pointer-events: auto;
            margin: 20px;
            display: flex; flex-direction: column; gap: 15px;
            align-items: flex-start;
        }

        /* é‡‘è‰²æŒ‰é’®æ ·å¼ */
        .btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
            backdrop-filter: blur(4px);
            text-align: center;
            min-width: 120px;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn:hover { background: rgba(212, 175, 55, 0.2); box-shadow: 0 0 15px rgba(212, 175, 55, 0.3); }
        .btn:active { transform: scale(0.95); }

        /* éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† */
        input[type="file"] { display: none; }

        /* æ‘„åƒå¤´å°çª—å£ */
        #video-feedback {
            position: absolute; bottom: 20px; right: 20px;
            width: 120px; height: 90px;
            border: 1px solid #333; border-radius: 8px;
            transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
            object-fit: cover;
        }
        #video-feedback.active { opacity: 0.8; border-color: #d4af37; }

        /* åŠ è½½æç¤º */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 14px; pointer-events: none; transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="loader">æ­£åœ¨åˆå§‹åŒ–...</div>

    <div id="ui-layer">
        <div class="header">Merry Christmas</div>
        
        <div class="controls">
            <button class="btn" onclick="triggerShape('tree')">ğŸ„ åœ£è¯æ ‘</button>
            <button class="btn" onclick="triggerShape('sphere')">ğŸ’¥ ç²’å­çˆ†ç‚¸</button>
            
            <button class="btn" onclick="document.getElementById('img-upload').click()">
                ğŸ–¼ï¸ æ·»åŠ ç…§ç‰‡
            </button>
            <input type="file" id="img-upload" accept="image/*">

            <button class="btn" onclick="document.getElementById('music-upload').click()">
                ğŸµ æ·»åŠ éŸ³ä¹
            </button>
            <input type="file" id="music-upload" accept="audio/*">
        </div>
    </div>
    
    <video id="video-feedback" playsinline muted></video>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            particleCount: 15000, // ç²’å­æ•°é‡ (æ‰‹æœºç«¯å¯é€‚å½“å‡å°‘)
            particleSize: 2.0,
            color: 0xd4af37, // é‡‘è‰²
            imgSize: 200 // å›¾åƒé‡‡æ ·å¤§å°
        };

        let scene, camera, renderer, particles, geometry;
        let targetPositions = []; // ç›®æ ‡ä½ç½®æ•°ç»„
        let currentPositions = []; // å½“å‰ä½ç½®æ•°ç»„
        let colors = [];
        let mouse = new THREE.Vector2();
        let isMouseDown = false;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        // éŸ³é¢‘åˆ†æ
        let audioContext, analyser, dataArray;
        let isAudioPlaying = false;

        init();
        animate();

        function init() {
            // 1. Three.js åŸºç¡€è®¾ç½®
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 600;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // 2. ç²’å­ç³»ç»Ÿåˆå§‹åŒ–
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const initialColors = new Float32Array(CONFIG.particleCount * 3);
            
            // åˆå§‹éšæœºä½ç½®
            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions[i * 3] = (Math.random() * 2000) - 1000;
                positions[i * 3 + 1] = (Math.random() * 2000) - 1000;
                positions[i * 3 + 2] = (Math.random() * 2000) - 1000;
                
                // é»˜è®¤é‡‘è‰²
                const color = new THREE.Color(CONFIG.color);
                initialColors[i * 3] = color.r;
                initialColors[i * 3 + 1] = color.g;
                initialColors[i * 3 + 2] = color.b;

                // è®°å½•å½“å‰ä½ç½®
                currentPositions.push(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(initialColors, 3));

            // æè´¨
            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 3. äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onDocumentMouseMove);
            
            // æ‰‹æœºè§¦å±æ”¯æŒ
            document.addEventListener('touchstart', onTouchStart, {passive: false});
            document.addEventListener('touchmove', onTouchMove, {passive: false});

            // æ–‡ä»¶ä¸Šä¼ ç›‘å¬
            document.getElementById('img-upload').addEventListener('change', handleImageUpload);
            document.getElementById('music-upload').addEventListener('change', handleMusicUpload);

            // åˆå§‹å½¢çŠ¶ï¼šåœ£è¯æ ‘
            document.getElementById('loader').style.opacity = 0;
            createTreeShape();
        }

        // --- å½¢çŠ¶ç”Ÿæˆå™¨ ---

        // 1. åœ£è¯æ ‘
        function createTreeShape() {
            targetPositions = [];
            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const angle = i * 0.1;
                const radius = 200 * (1 - i / count); // ä¸‹å¤§ä¸Šå°
                const x = radius * Math.cos(angle);
                const y = (i / count) * 400 - 200; // é«˜åº¦åˆ†å¸ƒ
                const z = radius * Math.sin(angle);
                targetPositions.push({x, y, z, r: 1, g: 0.84, b: 0}); // é»˜è®¤é‡‘è‰²
                
                // éšæœºç‚¹ç¼€çº¢è‰² (åœ£è¯çƒ)
                if (Math.random() > 0.95) {
                    targetPositions[i].r = 1; targetPositions[i].g = 0; targetPositions[i].b = 0;
                }
            }
            transitionToShape();
        }

        // 2. çˆ†ç‚¸çƒä½“
        function triggerShape(type) {
            if (type === 'tree') {
                createTreeShape();
                return;
            }
            
            // Sphere
            targetPositions = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const r = 300;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                targetPositions.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi),
                    r: Math.random(), g: Math.random(), b: Math.random() // å½©è‰²
                });
            }
            transitionToShape();
        }

        // 3. å¤„ç†ç…§ç‰‡ä¸Šä¼  (åƒç´ æ˜ å°„)
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.src = event.target.result;
                img.onload = function() {
                    sampleImage(img);
                };
            };
            reader.readAsDataURL(file);
        }

        function sampleImage(image) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = CONFIG.imgSize;
            canvas.height = CONFIG.imgSize;
            ctx.drawImage(image, 0, 0, CONFIG.imgSize, CONFIG.imgSize);
            
            const imgData = ctx.getImageData(0, 0, CONFIG.imgSize, CONFIG.imgSize);
            const data = imgData.data;
            
            targetPositions = [];
            let pIndex = 0;

            // éå†åƒç´ 
            for (let y = 0; y < CONFIG.imgSize; y++) {
                for (let x = 0; x < CONFIG.imgSize; x++) {
                    const i = (y * CONFIG.imgSize + x) * 4;
                    const alpha = data[i + 3];
                    
                    if (alpha > 128) { // åªå–ä¸é€æ˜çš„åƒç´ 
                        if (pIndex < CONFIG.particleCount) {
                            targetPositions.push({
                                x: (x - CONFIG.imgSize/2) * 3, // ç¼©æ”¾å¹¶å±…ä¸­
                                y: -(y - CONFIG.imgSize/2) * 3, // Yè½´åè½¬
                                z: 0,
                                r: data[i] / 255,
                                g: data[i+1] / 255,
                                b: data[i+2] / 255
                            });
                            pIndex++;
                        }
                    }
                }
            }
            transitionToShape();
        }

        // --- åŠ¨ç”»ä¸è¿‡æ¸¡ ---
        function transitionToShape() {
            // ä½¿ç”¨ GSAP æˆ–ç®€å•çš„ lerpï¼Œè¿™é‡Œä¸ºäº†æ€§èƒ½æ‰‹å†™ç®€å•çš„è¿‡æ¸¡é€»è¾‘
            // å®é™…ä¸Šåœ¨ animate å¾ªç¯ä¸­ä¼šä¸æ–­é€¼è¿‘ targetPositions
        }

        function handleMusicUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const audio = new Audio();
            audio.src = URL.createObjectURL(file);
            audio.crossOrigin = "anonymous";
            audio.play();
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioPlaying = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;
            const colorsAttr = geometry.attributes.color.array;
            
            let audioScale = 1;
            if (isAudioPlaying) {
                analyser.getByteFrequencyData(dataArray);
                const avg = dataArray.reduce((a,b)=>a+b,0) / dataArray.length;
                audioScale = 1 + (avg / 256) * 0.5; // éŸ³ä¹å¾‹åŠ¨ç³»æ•°
            }

            // ç²’å­ç§»åŠ¨æ ¸å¿ƒé€»è¾‘
            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (targetPositions[i]) {
                    const idx = i * 3;
                    const target = targetPositions[i];
                    
                    // 1. ä½ç½®æ’å€¼ (Lerp) - è®©ç²’å­é£å‘ç›®æ ‡
                    positions[idx] += (target.x * audioScale - positions[idx]) * 0.05;
                    positions[idx+1] += (target.y * audioScale - positions[idx+1]) * 0.05;
                    positions[idx+2] += (target.z * audioScale - positions[idx+2]) * 0.05;

                    // 2. é¢œè‰²æ’å€¼
                    colorsAttr[idx] += (target.r - colorsAttr[idx]) * 0.05;
                    colorsAttr[idx+1] += (target.g - colorsAttr[idx+1]) * 0.05;
                    colorsAttr[idx+2] += (target.b - colorsAttr[idx+2]) * 0.05;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // åœºæ™¯äº¤äº’æ—‹è½¬
            const time = Date.now() * 0.0005;
            scene.rotation.y += 0.002; // è‡ªåŠ¨è‡ªè½¬
            
            // é¼ æ ‡/æ‰‹æŒ‡äº¤äº’è§†å·®
            camera.position.x += (mouse.x * 200 - camera.position.x) * 0.05;
            camera.position.y += (-mouse.y * 200 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        // --- äº¤äº’å¤„ç† (æ‰‹æœº + PC) ---
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouse.x = (event.clientX - windowHalfX) / 2;
            mouse.y = (event.clientY - windowHalfY) / 2;
        }

        // æ‰‹æœºè§¦æ‘¸é€»è¾‘
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                mouse.x = (event.touches[0].pageX - windowHalfX) / 2;
                mouse.y = (event.touches[0].pageY - windowHalfY) / 2;
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                mouse.x = (event.touches[0].pageX - windowHalfX) / 2;
                mouse.y = (event.touches[0].pageY - windowHalfY) / 2;
            }
        }
    </script>
</body>
</html>